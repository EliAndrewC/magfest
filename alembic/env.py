from __future__ import with_statement

import logging
import sys
from logging.config import fileConfig
from alembic import context

import sideboard
import uber
from sideboard.lib.sa import CoerceUTF8, UTCDateTime, UUID
from uber.migration import version_locations_option
from uber.models import Choice, MultiChoice


logger = logging.getLogger('alembic.env')

# This is the Alembic Config object, which provides access to "alembic.ini".
config = context.config

assert version_locations_option == config.get_main_option('version_locations'), ('alembic '
        'must be run using the sep command:\n'
        'sep alembic {}'.format(' '.join(sys.argv[1:])))

# Interpret the config file for Python logging. This line sets up loggers.
if config.config_file_name:
    fileConfig(config.config_file_name)

# Add your model's MetaData object here for "autogenerate" support.
target_metadata = uber.models.Session.BaseClass.metadata


def include_object(object, name, type_, reflected, compare_to):
    """Exclude Alembic's own version tables from Alembic's consideration."""
    return not name.startswith('alembic_version')


def render_item(type_, obj, autogen_context):
    """Apply custom rendering for selected items."""
    if type_ == 'type':
        if isinstance(obj, Choice):
            return 'sa.Integer()'
        elif isinstance(obj, UTCDateTime):
            return 'sa.DateTime()'
        elif isinstance(obj, (CoerceUTF8, MultiChoice)):
            return 'sa.Unicode()'
        elif isinstance(obj, UUID):
            if autogen_context.dialect.name == 'postgresql':
                autogen_context.imports.add('from sqlalchemy.dialects import postgresql')
                return 'postgresql.UUID()'
            else:
                return 'sa.Unicode()'

    # default rendering for other objects
    return False


def process_revision_directives(context, revision, directives):
    """If an empty migration is autogenerated, don't create a script."""
    if config.cmd_opts.autogenerate:
        script = directives[0]
        if script.upgrade_ops.is_empty():
            directives[:] = []
            logger.info('Nothing to do.')


def run_migrations_offline():
    """Run migrations in "offline" mode.

    This configures the context with just a URL and not an Engine, though an
    Engine is acceptable here as well.  By skipping the Engine creation we
    don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the script output.

    """
    context.configure(
        include_object=include_object,
        url=uber.config.c.SQLALCHEMY_URL,
        target_metadata=target_metadata,
        render_item=render_item,
        literal_binds=True,
        process_revision_directives=process_revision_directives)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in "online" mode.

    In this scenario we need to create an Engine and associate a connection
    with the context.

    """
    connectable = config.attributes.get('connection', uber.models.Session.engine)

    with connectable.connect() as connection:
        context.configure(
            include_object=include_object,
            connection=connection,
            target_metadata=target_metadata,
            render_item=render_item,
            process_revision_directives=process_revision_directives)

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
